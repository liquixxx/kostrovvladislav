// isto4nik: https://www.guru99.com/ru/travelling-salesman-problem.html

#include <bits/stdc++.h>
using namespace std;
#define V 4          // Количество вершин в графе
#define MAX 1000000  // Большое число для инициализации минимальной стоимости

int tsp(int graph[][V], int s)  // Функция решения задачи коммивояжера
{
    // Шаг 1: Создаем список всех вершин кроме стартовой
    vector<int> vertex;
    for (int i = 0; i < V; i++)
        if (i != s)
            vertex.push_back(i);
    
    int min_cost = MAX;  // Инициализируем минимальную стоимость большим числом
    
    // Шаг 2: Перебираем все возможные перестановки вершин
    while(next_permutation(vertex.begin(), vertex.end()))
     {
        // Шаг 3: Вычисляем стоимость текущего маршрута
        int current_cost = 0;
        int j = s;  // Начинаем с стартовой вершины
        
        // Проходим по всем вершинам в текущей перестановке
        for (int i = 0; i < vertex.size(); i++) {
            current_cost += graph[j][vertex[i]];  // Добавляем стоимость перехода
            j = vertex[i];  // Переходим к следующей вершине
        }
        
        // Шаг 4: Возвращаемся в начальную вершину
        current_cost += graph[j][s];
        
        // Шаг 5: Обновляем минимальную стоимость если нашли лучше
        min_cost = min(min_cost, current_cost);
        
        return min_cost;  // ВОЗМОЖНАЯ ОШИБКА: return должен быть после цикла!
	}
    // Должен быть еще один return здесь для случая, когда есть только одна перестановка
}

int main()
{
    // Матрица смежности графа (расстояния между городами)
    int graph[][V] = { 
        { 0, 10, 15, 20 },    // Расстояния от города 0
        { 10, 0, 35, 25 },    // Расстояния от города 1  
        { 15, 35, 0, 30 },    // Расстояния от города 2
        { 20, 25, 30, 0 }     // Расстояния от города 3
    };                      
    
    int s = 0;  // Стартовая вершина
    cout << tsp(graph, s) << endl;  // Выводим результат
    return 0;
}
